<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Internal System Monitor</title>

<style>
/* ======================= GLOBAL ======================= */
@font-face {
  font-family: "Matrix";
  src: local("Courier New"), monospace;
}

body {
  margin: 0;
  font-family: Matrix, monospace;
  background: #000;
  color: #7dfc8a;
  overflow-x: hidden;
}

/* Matrix canvas behind everything */
#matrix {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}

/* CRT scanlines */
body::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: repeating-linear-gradient(
    to bottom,
    rgba(0,0,0,0.17) 0px,
    rgba(0,0,0,0.17) 2px,
    rgba(0,0,0,0.20) 3px
  );
  z-index: 9999;
  mix-blend-mode: multiply;
  opacity: 0.35;
}

/* ======================= UI ======================= */
#ui {
  position: relative;
  z-index: 10;
  padding: 25px;
}

h1 {
  color: #6fffa3;
  letter-spacing: 2px;
  margin-bottom: 16px;
}

/* Dropzone */
#dropzone {
  border: 1px dashed rgba(0,255,65,0.4);
  padding: 30px;
  text-align: center;
  cursor: pointer;
  border-radius: 6px;
  background: rgba(0,0,0,0.4);
  margin-bottom: 20px;
}

/* Panels */
.panel {
  margin-bottom: 20px;
  background: rgba(0,0,0,0.55);
  padding: 14px;
  border-radius: 6px;
  border: 1px solid rgba(0,255,65,0.25);
}

.panel h3 {
  margin: 0 0 10px 0;
}

pre {
  background: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 6px;
  max-height: 260px;
  overflow-y: auto;
  font-size: 12px;
}

/* File result blocks */
.file-result {
  padding: 8px;
  margin-bottom: 10px;
  border-radius: 6px;
  border: 1px solid rgba(0,255,65,0.3);
}

.success { border-color: rgba(0,255,65,0.6); }
.fail    { border-color: rgba(255,60,60,0.6); }

.meta-line {
  font-size: 11px;
  opacity: 0.85;
  margin-bottom: 6px;
}

#exportBtn {
  padding: 8px 14px;
  border: 1px solid #6fffa3;
  background: black;
  color: #6fffa3;
  cursor: pointer;
  border-radius: 4px;
}
</style>
</head>

<body>

<!-- MATRIX CANVAS -->
<canvas id="matrix"></canvas>

<!-- ======================= UI ======================= -->
<div id="ui">

  <h1>Internal System Monitor</h1>

  <div id="dropzone">CLICK OR DRAG PDF(s)</div>
  <input type="file" id="fileInput" accept="application/pdf" multiple style="display:none">

  <div class="panel">
    <h3>Progress</h3>
    <pre id="progress">Waiting…</pre>
  </div>

  <div class="panel">
    <h3>Layer A — Website Summary Preview</h3>
    <pre id="summaryA">Upload a report to preview the on-page summary…</pre>
  </div>

  <div class="panel">
    <h3>Success</h3>
    <div id="results"></div>
  </div>

  <div class="panel">
    <h3>Failed</h3>
    <div id="fails"></div>
  </div>

  <button id="exportBtn">Export JSON</button>
</div>

<script>
/* ======================= MATRIX RAIN ======================= */
const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");

function resizeMatrix() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeMatrix();
window.addEventListener("resize", resizeMatrix);

const chars = "アカサタナハマヤラワ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const charset = chars.split("");
const fontSize = 16;
let columns = Math.floor(canvas.width / fontSize);
let drops = Array.from({ length: columns }, () => 1);

function drawMatrix() {
  ctx.fillStyle = "rgba(0,0,0,0.07)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "rgba(0,255,65,0.55)";
  ctx.font = fontSize + "px Matrix";

  drops.forEach((y, i) => {
    const text = charset[Math.floor(Math.random() * charset.length)];
    ctx.fillText(text, i * fontSize, y * fontSize);

    if (y * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
    drops[i]++;
  });
}
setInterval(drawMatrix, 50);

/* ======================= TESTER LOGIC ======================= */

const dropzone = document.getElementById("dropzone");
const fileInput = document.getElementById("fileInput");
const progress = document.getElementById("progress");
const resultsDiv = document.getElementById("results");
const failsDiv = document.getElementById("fails");
const exportBtn = document.getElementById("exportBtn");
const summaryA = document.getElementById("summaryA");

let allResults = [];

dropzone.onclick = () => fileInput.click();
fileInput.onchange = () => handleFiles(fileInput.files);

dropzone.addEventListener("dragover", e => {
  e.preventDefault();
});
dropzone.addEventListener("drop", e => {
  e.preventDefault();
  handleFiles(e.dataTransfer.files);
});

// ---------- Layer A formatter (website copy) ----------
function buildLayerASummary(json) {
  if (!json || !json.ok || !json.underwrite) {
    return "We analyzed your file, but the analyzer returned a fallback result. This would show the manual-review message on the website.";
  }

  const uw = json.underwrite;
  const metrics = uw.metrics || {};
  const inquiries = (metrics.inquiries && metrics.inquiries.total) || 0;

  const bureauKey = uw.primary_bureau || "your strongest bureau";
  const bureau =
    typeof bureauKey === "string"
      ? bureauKey.toUpperCase()
      : "YOUR STRONGEST BUREAU";

  const score = metrics.score;
  const util = metrics.utilization_pct;
  const negatives = metrics.negative_accounts ?? 0;

  const totalFunding =
    (uw.totals && uw.totals.total_combined_funding) ||
    uw.lite_banner_funding ||
    null;

  const sentences = [];

  // 1) Opening: what we did + strongest bureau
  if (typeof score === "number" && Number.isFinite(score)) {
    sentences.push(
      `We scanned your full credit profile and your strongest funding bureau is ${bureau} with a score around ${score}.`
    );
  } else {
    sentences.push(
      `We scanned your full credit profile and identified ${bureau} as your strongest funding bureau.`
    );
  }

  // 2) Utilization
  if (typeof util === "number" && Number.isFinite(util)) {
    sentences.push(
      `Your overall utilization is about ${util}%. To maximize approvals, each card should land in the 3–10% range before you apply for new funding.`
    );
  } else {
    sentences.push(
      `We couldn’t cleanly read utilization from this PDF, but the target is simple: keep each card in the 3–10% range before applying.`
    );
  }

  // 3) Negatives + inquiries
  if (negatives > 0 || inquiries > 0) {
    const negPart =
      negatives > 0
        ? `${negatives} negative account${negatives > 1 ? "s" : ""}`
        : null;
    const inqPart =
      inquiries > 0 ? `${inquiries} recent inquir${inquiries === 1 ? "y" : "ies"}` : null;

    let combo = [];
    if (negPart) combo.push(negPart);
    if (inqPart) combo.push(inqPart);

    sentences.push(
      `Right now, ${combo.join(" and ")} are suppressing your approvals. Cleaning these up is the fastest way to unlock better limits.`
    );
  } else {
    sentences.push(
      `You have a clean file with no major negatives or inquiry drag, which is ideal for high-limit approvals.`
    );
  }

  // 4) Funding potential
  if (uw.fundable && totalFunding && totalFunding > 0) {
    const formatted = Math.round(totalFunding).toLocaleString();
    sentences.push(
      `Based on this profile, it’s realistic to target roughly $${formatted} in combined personal and business limits once you sequence applications correctly.`
    );
  } else {
    sentences.push(
      `You’re close to fundable — if you follow the clean-up steps we outline, you can move into approval range and then stack funding in a structured sequence.`
    );
  }

  // 5) CTA-ish line
  sentences.push(
    `On the next steps we’ll show you exactly what to fix first so you can move into maximum funding range as quickly as possible.`
  );

  return sentences.join(" ");
}

async function handleFiles(files) {
  if (!files || !files.length) return;

  allResults = [];
  resultsDiv.innerHTML = "";
  failsDiv.innerHTML = "";
  progress.innerText = "Starting…";
  summaryA.textContent = "Waiting for first successful result…";

  const total = files.length;
  let done = 0;

  for (const file of files) {
    await processFile(file);
    done++;
    const pct = ((done / total) * 100).toFixed(1);
    progress.innerText = `Processed ${done} / ${total} (${pct}%)`;
  }

  progress.innerText = `DONE – ${total} files tested`;
}

async function processFile(file) {
  const formData = new FormData();
  formData.append("file", file);

  let json;
  try {
    const res = await fetch("/api/lite/parse-report", {
      method: "POST",
      body: formData
    });
    json = await res.json();
  } catch (err) {
    json = { ok: false, error: true, message: err.toString() };
  }

  // Track all
  allResults.push({ filename: file.name, size: file.size, result: json });

  const div = document.createElement("div");
  div.className = "file-result " + (json.ok ? "success" : "fail");

  const sizeKb = (file.size / 1024).toFixed(1);

  div.innerHTML = `
    <div class="meta-line">
      FILE: ${file.name} — ${sizeKb} KB
    </div>
    <pre>${JSON.stringify(json, null, 2)}</pre>
  `;

  if (json.ok) {
    resultsDiv.appendChild(div);
    // Update Layer A summary for the most recent successful file
    summaryA.textContent = buildLayerASummary(json);
  } else {
    failsDiv.appendChild(div);
  }
}

exportBtn.onclick = () => {
  const blob = new Blob([JSON.stringify(allResults, null, 2)], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "uwiq-results.json";
  a.click();
  URL.revokeObjectURL(url);
};
</script>

</body>
</html>
